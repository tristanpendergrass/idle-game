Effects are how we give the players resources.

A basic effect type is GainCoin which specifies how much coin to grant the player.

Sometimes an Event is happening which has multiple effects like gain a coin and gain a resource. We group them up and execute them in whatever order. When they're all additive this is very simple.

Some Events have effects that subtract though, either coin, resources, or whatever. More generally, some effects can Err. Effects have a property called `requirement` with a type like:

```
type Requirement =
	| Required 
	| Optional (List Effect) -- extra effects are added to Event if this Effect is Err
```


- What happens when granted a resource that we already have max stacks of and we grant coin instead?
Idea: gaining the resource results in Err, but Effect is not marked Required so the alt effect GainCoin is created.

- What happens when an activity requires an input that we don't have?
This is modeled as the Event having an Effect that is required but the reducer returns Err when applying the effect to the model at this point in time.

- What happens when a mod gives an activity "resource preservation" chance

If an attribute of an effect is universal it should go in the reducer, otherwise it should go in the effect type somehow. For instance the fact that you can't give resources above a certain cap is universal, there can never be an instance of giving a resource that isn't this way, so it should be built into the reducer. For organizational reasons we want the reducer to be able to generate additional effects which go through the effect pipeline again. E.g. if a resource is gained but we're at the cap then sell it for gold, along with any bonuses for selling included. Another matter is what about required resources such as parchment for creating all spells? What part of the pipeline accounts for this?

## Event Pipeline
* Tick function notices an Activity completed and gets the event and mods
    * Right now we do this by storing the Event on the activity stats but it could be generated by a case statement that includes the state of model if we need that
    * The mods are derived from the model. Includes items equipped, mastery thresholds, spells equipped.
* Extract the effects for the event as a list
* Apply the mods to each effect, checking if all the tags on the mod are on the effect.
* A side effect of applying mods is that a particular effect could disappear or more could be added (e.g. parchment not required for this, or whenever you get coin also get a 5% chance of a ruby). So applying a mod to an effect can be a recursive process where any new effects also need all mods applied to them.
* Gather all modded effects into a list and sort them (usually it shouldn't matter but gains should come before losses)
* Do a `foldl` over the Game object, applying a `reduce` function to the model for each effect
    * This `reduce` function does a lot of the heavy lifting of the game logic and should be thoroughly tested. It has to do everything from simple adding resources to resolving probabilities. On the other hand it doesn't have to handle modding effects.

## Requirements
In principle the `reducer` can decide after applying any effect that it failed which will stop the application of the entire event. This should happen when e.g. a resource is going to be removed but the player has zero. 

## Additional Effects during reducing
The `reducer` can create new effects when applying an effect, just as mods can do. These will need to be modded, added to the list in sort order, and applied in turn. For instance resolving the addition of a resource that you are already at the cap of might cause you go gain coin instead.

## Effects to test
* Gain/lose coin (Result vs Err on loss)
* Gain/lose resource (Result vs Err on loss)

## Scenarios to test
* Gain a coin
* Gain a coin with multiplier
* Sell a resource
* Gain a resource
* Gain a resource with doubling % chance
* Gain a resource at resource cap (generates a gain coin)
* Lose a resource to gain a resource
* Try to lose a resource to gain a resource but you have no more
* % chance to lose a resource (success)

### Technical issue
Do we throw the err when creating the generator or as the result of the generator?